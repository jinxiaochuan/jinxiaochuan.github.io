{"title":"浏览器缓存及内容协商","uid":"0f1e554315f0274ca298957330a8910f","slug":"broswer-cache","date":"2022-02-12T13:40:50.000Z","updated":"2022-02-13T07:09:29.072Z","comments":true,"path":"api/articles/broswer-cache.json","keywords":null,"cover":[],"content":"<h4 id=\"浏览器的缓存机制\"><a href=\"#浏览器的缓存机制\" class=\"headerlink\" title=\"浏览器的缓存机制\"></a>浏览器的缓存机制</h4><p>浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>浏览器缓存过程： <code>强缓存</code>、<code>协商缓存</code>。<br>浏览器缓存位置一般分为四类： <code>Service Worker</code>、<code>Memory Cache</code>、<code>Disk Cache</code>、<code>Push Cache</code></p></blockquote>\n<h5 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h5><p>强缓存是当我们访问 URL 的时候，不会向服务器发送请求，直接从缓存中读取资源，但是会返回 200 的状态码。</p>\n<h6 id=\"如何设置强缓存？\"><a href=\"#如何设置强缓存？\" class=\"headerlink\" title=\"如何设置强缓存？\"></a>如何设置强缓存？</h6><p>我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据 response Header 来判断是否对资源进行缓存，如果响应头中 expires、pragma 或者 cache-control 字段，代表这是强缓存，浏览器就会把资源缓存在 memory cache 或 disk cache 中。</p>\n<p>第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码 200，从本地缓存中拿数据。否则把响应参数存在 request header 请求头中，看是否符合协商缓存，符合则返回状态码 304，不符合则服务器会返回全新资源。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca00bff3081e4cfd993a8f252f4fa23a~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"browser-cache\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h6 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h6><p>是 HTTP1.0 控制网页缓存的字段，值为一个时间戳，准确来讲是格林尼治时间，服务器返回该请求结果缓存的到期时间，意思是，再次发送请求时，如果未超过过期时间，直接使用该缓存，如果过期了则重新请求。<br><code>缺点：就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。</code></p>\n<h6 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h6><p>是 HTTP1.1 中控制网页缓存的字段，当 Cache-Control 都存在时，Cache-Control 优先级更高</p>\n<ul>\n<li><code>public</code>：资源客户端和服务器都可以缓存。</li>\n<li><code>private</code>：资源只有客户端可以缓存。</li>\n<li><code>no-cache</code>：客户端缓存资源，但是是否缓存需要经过协商缓存来验证。</li>\n<li><code>no-store</code>：不使用缓存。</li>\n<li><code>max-age</code>：最大过期时间（距离当前请求的时间差）</li>\n</ul>\n<blockquote>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f169e913e244d52a44ff1e4185cb9ce~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"Cache-Control\"><br>Cache-Control 使用了 max-age 相对时间，解决了 expires 的问题</p></blockquote>\n<h6 id=\"Pragma\"><a href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"></a>Pragma</h6><p>这个是 HTTP1.0 中禁用网页缓存的字段，其取值为 no-cache，和 Cache-Control 的 no-cache 效果一样</p>\n<h6 id=\"Vary-内容协商\"><a href=\"#Vary-内容协商\" class=\"headerlink\" title=\"Vary(内容协商)\"></a>Vary(内容协商)</h6><p>要了解 Vary 的作用，先得了解 HTTP 的内容协商机制。有时候，同一个 URL 可以提供多份不同的文档，这就要求服务端和客户端之间有一个选择最合适版本的机制，这就是内容协商.<br>服务端根据客户端发送的请求头中某些字段自动发送最合适的版本。可以用于这个机制的请求头字段又分两种：内容协商专用字段（Accept 字段）、其他字段.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">请求头字段</th>\n<th align=\"left\">说明</th>\n<th align=\"center\">响应头字段</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Accept</td>\n<td align=\"left\">告知服务器发送何种媒体类型</td>\n<td align=\"center\">Content-Type</td>\n</tr>\n<tr>\n<td align=\"center\">Accept-Language</td>\n<td align=\"left\">告知服务器发送何种语言</td>\n<td align=\"center\">Content-Language</td>\n</tr>\n<tr>\n<td align=\"center\">Accept-Charset</td>\n<td align=\"left\">告知服务器发送何种字符集</td>\n<td align=\"center\">Content-Type</td>\n</tr>\n<tr>\n<td align=\"center\">Accept-Encoding</td>\n<td align=\"left\">告知服务器采用何种压缩方式</td>\n<td align=\"center\">Content-Encoding</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">// 例如客户端发送以下请求头\n// 表示它可以接受任何 MIME 类型的资源；支持采用 gzip、deflate 或 sdch 压缩过的资源；可以接受 zh-CN、en-US 和 en 三种语言，并且 zh-CN 的权重最高（q 取值 <span class=\"token number\">0</span> - <span class=\"token number\">1</span>，最高为 <span class=\"token number\">1</span>，最低为 <span class=\"token number\">0</span>，默认为 <span class=\"token number\">1</span>），服务端应该优先返回语言等于 zh-CN 的版本。\nAccept:*/*\nAccept-Encoding:gzip,deflate,sdch\nAccept-Language:zh-CN,en-US<span class=\"token punctuation\">;</span><span class=\"token assign-left variable\">q</span><span class=\"token operator\">=</span><span class=\"token number\">0.8</span>,en<span class=\"token punctuation\">;</span><span class=\"token assign-left variable\">q</span><span class=\"token operator\">=</span><span class=\"token number\">0.6</span>\n\n// 浏览器的响应头可能是这样的\n// 表示这个文档确切的 MIME 类型是 text/javascript；文档内容进行了 <span class=\"token function\">gzip</span> 压缩；响应头没有 Content-Language 字段，通常说明返回版本的语言正好是请求头 Accept-Language 中权重最高的那个\nContent-Type: text/javascript\nContent-Encoding: <span class=\"token function\">gzip</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面四个 Accept 字段并不够用，例如要针对特定浏览器如 IE6 输出不一样的内容，就需要用到请求头中的 User-Agent 字段。类似的，请求头中的 Cookie 也可能被服务端用做输出差异化内容的依据。<br>由于客户端和服务端之间可能存在一个或多个中间实体（如缓存服务器），而缓存服务最基本的要求是给用户返回正确的文档。如果服务端根据不同 User-Agent 返回不同内容，而缓存服务器把 IE6 用户的响应缓存下来，并返回给使用其他浏览器的用户，肯定会出问题<br>所以 HTTP 协议规定，如果服务端提供的内容取决于 User-Agent 这样「常规 Accept 协商字段之外」的请求头字段，那么响应头中必须包含 Vary 字段，且 Vary 的内容必须包含 User-Agent。同理，如果服务端同时使用请求头中 User-Agent 和 Cookie 这两个字段来生成内容，那么响应中的 Vary 字段看上去应该是这样的：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Vary: User-Agent, Cookie<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>也就是说 Vary 字段用于列出一个响应字段列表，告诉缓存服务器遇到同一个 URL 对应着不同版本文档的情况时，如何缓存和筛选合适的版本。</p>\n</blockquote>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c82d0049c3f4f57bf66d8effcb25ed5~tplv-k3u1fbpfcp-watermark.awebp\"></p>\n<h5 id=\"缓存位置\"><a href=\"#缓存位置\" class=\"headerlink\" title=\"缓存位置\"></a>缓存位置</h5><p>强缓存会把资源房放到 memory cache 和 disk cache 中，那什么资源放在 memory cache，什么资源放在 disk cache 中？</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c6020dcbb114111a8e0a09f52d39ab7~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"memory cache vs disk cache\"></p>\n<p>查找浏览器缓存时会按顺序查找: <code>Service Worker</code> -&gt; <code>Memory Cache</code> -&gt; <code>Disk Cache</code> -&gt; <code>Push Cache</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h6 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"></a>Service Worker</h6><p>是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>\n<h6 id=\"Memory-Cache\"><a href=\"#Memory-Cache\" class=\"headerlink\" title=\"Memory Cache\"></a>Memory Cache</h6><p>内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>\n<h6 id=\"Disk-Cache\"><a href=\"#Disk-Cache\" class=\"headerlink\" title=\"Disk Cache\"></a>Disk Cache</h6><p>存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。<br>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。<br>memory cache 要比 disk cache 快的多。举个例子：从远程 web 服务器直接提取访问文件可能需要 500 毫秒(半秒)，那么磁盘访问可能需要 10-20 毫秒，而内存访问只需要 100 纳秒，更高级的还有 L1 缓存访问(最快和最小的 CPU 缓存)只需要 0.5 纳秒。<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6216b57ad4cb480884c2b69d0f0ffe26~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"prefetch cache\"><br>很神奇的，我们又看到了一个 prefetch cache，这个又是什么呢?</p>\n<blockquote>\n<p><code>prefetch cache(预取缓存)</code><br>link 标签上带了 prefetch，再次加载会出现。<br>prefetch 是预加载的一种方式，被标记为 prefetch 的资源，将会被浏览器在空闲时间加载。 4. Push Cache</p></blockquote>\n<h6 id=\"Push-Cache-推送缓存\"><a href=\"#Push-Cache-推送缓存\" class=\"headerlink\" title=\"Push Cache(推送缓存)\"></a>Push Cache(推送缓存)</h6><p>是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>\n</blockquote>\n<h5 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h5><p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。</p>\n<h6 id=\"协商缓存生效，返回-304\"><a href=\"#协商缓存生效，返回-304\" class=\"headerlink\" title=\"协商缓存生效，返回 304\"></a>协商缓存生效，返回 304</h6><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f26ab979fcd4df6906a2e9d5e28f56a~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"协商缓存生效\"></p>\n<h6 id=\"协商缓存失效，返回-200-和请求结果\"><a href=\"#协商缓存失效，返回-200-和请求结果\" class=\"headerlink\" title=\"协商缓存失效，返回 200 和请求结果\"></a>协商缓存失效，返回 200 和请求结果</h6><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/449a56554c1e4f0c949e139081a9db4c~tplv-k3u1fbpfcp-watermark.awebp\" alt=\"协商缓存失效\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h6 id=\"Last-Modified-x2F-If-Modified-Since\"><a href=\"#Last-Modified-x2F-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified &#x2F; If-Modified-Since\"></a>Last-Modified &#x2F; If-Modified-Since</h6><p>Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。<br>If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。</p>\n<h6 id=\"Etag-x2F-If-None-Match\"><a href=\"#Etag-x2F-If-None-Match\" class=\"headerlink\" title=\"Etag &#x2F; If-None-Match\"></a>Etag &#x2F; If-None-Match</h6><p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。<br>If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200。</p></blockquote>\n<h4 id=\"CORS-与-Vary-Origin\"><a href=\"#CORS-与-Vary-Origin\" class=\"headerlink\" title=\"CORS 与 Vary: Origin\"></a>CORS 与 Vary: Origin</h4><p>在讨论 CORS 与 Vary 关系时，先抛出一个问题：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何避免 CDN 为 PC 端缓存移动端页面？</p></blockquote>\n<p>假设有两个域名访问 <code>static.shanyue.tech</code> 的跨域资源</p>\n<ol>\n<li><code>foo.shanyue.tech</code>，响应头中返回 <code>Access-Control-Allow-Origin: foo.shanyue.tech</code></li>\n<li><code>bar.shanyue.tech</code>，响应头中返回 <code>Access-Control-Allow-Origin: bar.shanyue.tech</code></li>\n</ol>\n<p>看起来一切正常，但平静的水面下波涛暗涌:</p>\n<p>「如果 <code>static.shanyue.tech</code> 资源被 CDN 缓存，<code>bar.shanyue.tech</code> 再次访问资源时，因缓存问题，因此此时返回的是 <code>Access-Control-Allow-Origin: foo.shanyue.tech</code>，此时会有跨域问题」</p>\n<p>此时，Vary: Origin 就上场了，代表为不同的 Origin 缓存不同的资源，这在各个服务器端 CORS 中间件也能体现出来。</p>\n<p><a href=\"https://github.com/koajs/cors/blob/master/index.js#L54\">Koa 关于 CORS 的处理函数</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">return</span> async <span class=\"token keyword\">function</span> cors<span class=\"token punctuation\">(</span>ctx, next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  // If the Origin header is not present terminate this <span class=\"token builtin class-name\">set</span> of steps.\n  // The request is outside the scope of this specification.\n  const requestOrigin <span class=\"token operator\">=</span> ctx.get<span class=\"token punctuation\">(</span><span class=\"token string\">'Origin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  // Always <span class=\"token builtin class-name\">set</span> Vary header\n  // https://github.com/rs/cors/issues/10\n  ctx.vary<span class=\"token punctuation\">(</span><span class=\"token string\">'Origin'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>服务器端通过响应头 <code>Origin</code> 来判断是否为跨域请求，并以此设置多域名跨域，但要加上 <code>Vary: Origin</code>。</p></blockquote>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\">彻底理解浏览器的缓存机制</a><br><a href=\"https://juejin.cn/post/6947936223126093861\">前端浏览器缓存知识梳理</a><br><a href=\"https://juejin.cn/post/6844904021308735502\">(1.6w 字)浏览器灵魂之问，请问你能接得住几个？</a><br><a href=\"https://juejin.cn/post/7000231382731456520\">HTTP 协议中 Vary 的一些研究</a><br><a href=\"https://cloud.tencent.com/developer/article/1693677?from=15425\">浏览器中的跨域问题与 CORS</a></p>\n","feature":true,"text":"浏览器的缓存机制浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的。 浏览器缓存过程： 强缓存、协商缓存。浏览器缓存位置一般分为四类： Service Worker、Memory Cache、Disk Cache、Push Cache...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"HTTP","slug":"HTTP","count":2,"path":"api/tags/HTTP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">浏览器的缓存机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">强缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%BC%BA%E7%BC%93%E5%AD%98%EF%BC%9F\"><span class=\"toc-text\">如何设置强缓存？</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Expires\"><span class=\"toc-text\">Expires</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Cache-Control\"><span class=\"toc-text\">Cache-Control</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Pragma\"><span class=\"toc-text\">Pragma</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Vary-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86\"><span class=\"toc-text\">Vary(内容协商)</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">缓存位置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Service-Worker\"><span class=\"toc-text\">Service Worker</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Memory-Cache\"><span class=\"toc-text\">Memory Cache</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Disk-Cache\"><span class=\"toc-text\">Disk Cache</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Push-Cache-%E6%8E%A8%E9%80%81%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">Push Cache(推送缓存)</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">协商缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E7%94%9F%E6%95%88%EF%BC%8C%E8%BF%94%E5%9B%9E-304\"><span class=\"toc-text\">协商缓存生效，返回 304</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%EF%BC%8C%E8%BF%94%E5%9B%9E-200-%E5%92%8C%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">协商缓存失效，返回 200 和请求结果</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Last-Modified-x2F-If-Modified-Since\"><span class=\"toc-text\">Last-Modified &#x2F; If-Modified-Since</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Etag-x2F-If-None-Match\"><span class=\"toc-text\">Etag &#x2F; If-None-Match</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CORS-%E4%B8%8E-Vary-Origin\"><span class=\"toc-text\">CORS 与 Vary: Origin</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CORS vs HSTS","uid":"78e195a173181f2e8327460e98bdacbc","slug":"cors","date":"2022-02-12T16:54:51.000Z","updated":"2022-02-13T07:09:29.072Z","comments":true,"path":"api/articles/cors.json","keywords":null,"cover":[],"text":"浏览器同源策略所谓同源就是浏览器的一个安全机制,不同源的客户端脚本没有在明确授权的情况下,不能读写对方资源。由于存在同源策略的限制,而又有需要跨域的业务,所以就有了 CORS 的出现。 当资源位于不同协议、子域或端口的站点时，这个请求就是跨域的 CORS 与 HSTSHSTS 全...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"HTTP","slug":"HTTP","count":2,"path":"api/tags/HTTP.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Monorepo","uid":"230f463a6828a545fa6d14af02ab1fd6","slug":"monorepo","date":"2022-02-09T23:18:46.000Z","updated":"2022-02-13T07:09:29.072Z","comments":true,"path":"api/articles/monorepo.json","keywords":null,"cover":[],"text":"什么是 Monorepo?Monorepo 其实不是一个新的概念，在软件工程领域，它已经有着十多年的历史了。概念上很好理解，就是把多个项目放在一个仓库里面，相对立的是传统的 MultiRepo 模式，即每个项目对应一个单独的仓库来分散管理。 Monorepo 是一种将多个项目代码...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Monorepo","slug":"Monorepo","count":1,"path":"api/tags/Monorepo.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}