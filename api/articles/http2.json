{"title":"HTTP2","uid":"51e9acccf01c1d764ee3a75bbf79b49b","slug":"http2","date":"2022-02-08T22:19:20.000Z","updated":"2022-02-20T11:34:02.353Z","comments":true,"path":"api/articles/http2.json","keywords":null,"cover":[],"content":"<p>维基百科关于 HTTP&#x2F;2 的介绍，可以看下定义和发展历史:</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/HTTP/2\">Wiki</a></p>\n<p>RFC 7540 定义了 HTTP&#x2F;2 的协议规范和细节，本文的细节主要来自此文档，建议先看一遍本文，再回过头来照着协议大致过一遍 RFC，如果想深入某些细节再仔细翻看 RFC</p>\n<p><a href=\"https://httpwg.org/specs/rfc7540.html\">RFC7540</a></p>\n<h4 id=\"Why-use-it\"><a href=\"#Why-use-it\" class=\"headerlink\" title=\"Why use it ?\"></a>Why use it ?</h4><p>HTTP&#x2F;1.1 存在的问题:</p>\n<ol>\n<li>TCP 连接数限制<br>对于同一个域名，浏览器最多只能同时创建 6 - 8 个 TCP 连接 (不同浏览器不一样)。为了解决数量限制，出现了 域名分片 技术，其实就是资源分域，将资源放在不同域名下 (比如二级子域名下)，这样就可以针对不同域名创建连接并请求，以一种讨巧的方式突破限制，但是滥用此技术也会造成很多问题，比如每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，还占用额外的 CPU 和内存，对于服务器来说过多连接也容易造成网络拥挤、交通阻塞等，对于移动端来说问题更明显，可以参考这篇文章: Why Domain Sharding is Bad News for Mobile Performance and Users。<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4aba66d424~tplv-t2oaga2asx-watermark.awebp\" alt=\"http/1.1-1\"><br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4c0371bfda~tplv-t2oaga2asx-watermark.awebp\" alt=\"http/1.1-2\"><br>在图中可以看到新建了六个 TCP 连接，每次新建连接 DNS 解析需要时间(几 ms 到几百 ms 不等)、TCP 慢启动也需要时间、TLS 握手又要时间，而且后续请求都要等待队列调度</li>\n<li>线头阻塞 (Head Of Line Blocking) 问题<br>每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。为了解决此问题，出现了 管线化 - pipelining 技术，但是管线化存在诸多问题，比如第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化</li>\n<li>Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案</li>\n<li>为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制</li>\n<li>明文传输不安全</li>\n</ol>\n<h4 id=\"HTTP2-的优势\"><a href=\"#HTTP2-的优势\" class=\"headerlink\" title=\"HTTP2 的优势\"></a>HTTP2 的优势</h4><h6 id=\"二进制分帧层-Binary-Framing-Layer\"><a href=\"#二进制分帧层-Binary-Framing-Layer\" class=\"headerlink\" title=\"二进制分帧层 (Binary Framing Layer)\"></a>二进制分帧层 (Binary Framing Layer)</h6><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧:</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4b44118517~tplv-t2oaga2asx-watermark.awebp\"></p>\n<p>h1 和 h2 的报文对比:</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4b6cd4a1f9~tplv-t2oaga2asx-watermark.awebp\"><br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4b5f730d3e~tplv-t2oaga2asx-watermark.awebp\"></p>\n<p>图中 h2 的报文是重组解析过后的，可以发现一些头字段发生了变化，而且所有头字段均小写</p>\n<h6 id=\"多路复用-MultiPlexing\"><a href=\"#多路复用-MultiPlexing\" class=\"headerlink\" title=\"多路复用 (MultiPlexing)\"></a>多路复用 (MultiPlexing)</h6><p>在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。<br>把 HTTP&#x2F;1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP&#x2F;2 中的多路复用。</p>\n<p>流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题</p>\n<p>所以 http2 对于同一域名只需要创建一个连接，而不是像 http&#x2F;1.1 那样创建 6~8 个连接:</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4cc1d61446~tplv-t2oaga2asx-watermark.awebp\"><br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc4c5062c0ff~tplv-t2oaga2asx-watermark.awebp\"></p>\n<h6 id=\"服务端推送-Server-Push\"><a href=\"#服务端推送-Server-Push\" class=\"headerlink\" title=\"服务端推送 (Server Push)\"></a>服务端推送 (Server Push)</h6><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。<br>Server-Push 主要是针对资源内联做出的优化，相较于 http&#x2F;1.1 资源内联的优势:</p>\n<ul>\n<li>客户端可以缓存推送的资源</li>\n<li>客户端可以拒收推送过来的资源</li>\n<li>推送资源可以由不同页面共享</li>\n<li>服务器可以按照优先级推送资源</li>\n</ul>\n<h6 id=\"Header-压缩-HPACK\"><a href=\"#Header-压缩-HPACK\" class=\"headerlink\" title=\"Header 压缩 (HPACK)\"></a>Header 压缩 (HPACK)</h6><p>使用 <a href=\"https://httpwg.org/specs/rfc7541.html\">HPACK</a> 算法来压缩首部内容<br><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/31/1658dc53114a2ab9~tplv-t2oaga2asx-watermark.awebp\"><br>上图来自 Ilya Grigorik 的 PPT - HTTP&#x2F;2 is here, let’s optimize!</p>\n<p>可以清楚地看到 HTTP2 头部使用的也是键值对形式的值，而且 HTTP1 当中的请求行以及状态行也被分割成键值对，还有所有键都是小写，不同于 HTTP1。除此之外，还有一个包含静态索引表和动态索引表的索引空间，实际传输时会把头部键值表压缩，使用的算法即 HPACK，其原理就是匹配当前连接存在的索引空间，若某个键值已存在，则用相应的索引代替首部条目，比如 “:method: GET” 可以匹配到静态索引中的 index 2，传输时只需要传输一个包含 2 的字节即可；若索引空间中不存在，则用字符编码传输，字符编码可以选择哈夫曼编码，然后分情况判断是否需要存入动态索引表中</p>\n<ol>\n<li>静态索引<br>静态索引表是固定的，对于客户端服务端都一样，目前协议商定的静态索引包含 61 个键值，详见 Static Table Definition - RFC 7541，比如前几个如下<table>\n<thead>\n<tr>\n<th align=\"center\">索引</th>\n<th align=\"left\">字段值</th>\n<th align=\"center\">键值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">index</td>\n<td align=\"left\">Header Name</td>\n<td align=\"center\">Header Value</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"left\">:authority</td>\n<td align=\"center\">单元格</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"left\">:method</td>\n<td align=\"center\">GET</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"left\">:method</td>\n<td align=\"center\">POST</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"left\">:path</td>\n<td align=\"center\">&#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"left\">:path</td>\n<td align=\"center\">&#x2F;index.html</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"left\">:scheme</td>\n<td align=\"center\">http</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"left\">:scheme</td>\n<td align=\"center\">https</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"left\">:status</td>\n<td align=\"center\">200</td>\n</tr>\n</tbody></table>\n</li>\n<li>动态索引<br>动态索引表是一个 FIFO 队列维护的有空间限制的表，里面含有非静态表的索引。<br>动态索引表是需要连接双方维护的，其内容基于连接上下文，一个 HTTP2 连接有且仅有一份动态表。<br>当一个首部匹配不到索引时，可以选择把它插入动态索引表中，下次同名的值就可能会在表中查到索引并替换。<br>但是并非所有首部键值都会存入动态索引，因为动态索引表是有空间限制的，最大值由 SETTING 帧中的 SETTINGS_HEADER_TABLE_SIZE (默认 4096 字节) 设置</li>\n</ol>\n<h6 id=\"应用层的重置连接\"><a href=\"#应用层的重置连接\" class=\"headerlink\" title=\"应用层的重置连接\"></a>应用层的重置连接</h6><p>对于 HTTP&#x2F;1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP&#x2F;2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。</p>\n<h6 id=\"请求优先级设置\"><a href=\"#请求优先级设置\" class=\"headerlink\" title=\"请求优先级设置\"></a>请求优先级设置</h6><p>HTTP&#x2F;2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</p>\n<h6 id=\"HTTP-x2F-1-的几种优化可以弃用\"><a href=\"#HTTP-x2F-1-的几种优化可以弃用\" class=\"headerlink\" title=\"HTTP&#x2F;1 的几种优化可以弃用\"></a>HTTP&#x2F;1 的几种优化可以弃用</h6><p>合并文件、内联资源、雪碧图、域名分片对于 HTTP&#x2F;2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://juejin.cn/post/6844903667569541133\">HTTP2 详解</a><br><a href=\"https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A\">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p>\n","text":"维基百科关于 HTTP&#x2F;2 的介绍，可以看下定义和发展历史: Wiki RFC 7540 定义了 HTTP&#x2F;2 的协议规范和细节，本文的细节主要来自此文档，建议先看一遍本文，再回过头来照着协议大致过一遍 RFC，如果想深入某些细节再仔细翻看 RFC RFC75...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Network","slug":"Network","count":2,"path":"api/tags/Network.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Why-use-it\"><span class=\"toc-text\">Why use it ?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HTTP2-%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">HTTP2 的优势</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82-Binary-Framing-Layer\"><span class=\"toc-text\">二进制分帧层 (Binary Framing Layer)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-MultiPlexing\"><span class=\"toc-text\">多路复用 (MultiPlexing)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81-Server-Push\"><span class=\"toc-text\">服务端推送 (Server Push)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Header-%E5%8E%8B%E7%BC%A9-HPACK\"><span class=\"toc-text\">Header 压缩 (HPACK)</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E9%87%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">应用层的重置连接</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">请求优先级设置</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%98%E5%8C%96%E5%8F%AF%E4%BB%A5%E5%BC%83%E7%94%A8\"><span class=\"toc-text\">HTTP&#x2F;1 的几种优化可以弃用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Monorepo","uid":"230f463a6828a545fa6d14af02ab1fd6","slug":"monorepo","date":"2022-02-09T23:18:46.000Z","updated":"2022-02-20T11:34:02.353Z","comments":true,"path":"api/articles/monorepo.json","keywords":null,"cover":[],"text":"什么是 Monorepo?Monorepo 其实不是一个新的概念，在软件工程领域，它已经有着十多年的历史了。概念上很好理解，就是把多个项目放在一个仓库里面，相对立的是传统的 MultiRepo 模式，即每个项目对应一个单独的仓库来分散管理。 Monorepo 是一种将多个项目代码...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Monorepo","slug":"Monorepo","count":1,"path":"api/tags/Monorepo.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}