{"title":"从浏览器地址栏输入url之后经历了什么？","uid":"dd5d3edb93e33be831adceee904530d0","slug":"visit-website","date":"2022-03-20T16:29:49.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/visit-website.json","keywords":null,"cover":[],"content":"<h4 id=\"资源是否命中强缓存\"><a href=\"#资源是否命中强缓存\" class=\"headerlink\" title=\"资源是否命中强缓存\"></a>资源是否命中强缓存</h4><ol>\n<li>如果资源未缓存，发起新请求</li>\n<li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证</li>\n<li>检验新鲜通常有两个 <code>HTTP</code> 头进行控制 <code>Expires</code> 和 <code>Cache-Control</code>：<ul>\n<li><code>HTTP1.0</code> 提供 <code>Expires</code>，值为一个绝对时间表示缓存新鲜日期</li>\n<li><code>HTTP1.1</code> 增加了 <code>Cache-Control: max-age=xxx</code> ，值为以秒为单位的最大新鲜时间</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"DNS-解析\"><a href=\"#DNS-解析\" class=\"headerlink\" title=\"DNS 解析\"></a>DNS 解析</h4><ol>\n<li>浏览器缓存</li>\n<li>本机缓存</li>\n<li>hosts 文件</li>\n<li>路由器缓存</li>\n<li>ISP DNS 缓存</li>\n<li>DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>DNS 服务器有 3 种类型：<code>根DNS服务器</code>、<code>顶级域（Top-Level Domain, TLD）DNS 服务器</code> 和 <code>权威DNS服务器</code>。它们的层次结构如下图所示：<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408987c0882245cfb1c6a8d853c9d501~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\"></p>\n<ul>\n<li><em>根 DNS 服务器</em><br>首先我们要明确根域名是什么，比如 <code>www.baidu.com</code>，有些同学可能会误以为 <code>com</code> 就是根域名，其实 <code>com</code> 是顶级域名，<code>www.baidu.com</code> 的完整写法是 <code>www.baidu.com.</code>，最后的这个 <code>.</code> 就是根域名。<br><code>根DNS服务器</code>的作用是什么呢？就是管理它的下一级，也就是<code>顶级域DNS服务器</code>。通过询问<code>根DNS服务器</code>，我们可以知道一个主机名对应的<code>顶级域DNS服务器</code>的 <code>IP</code> 是多少，从而继续向<code>顶级域DNS服务器</code>发起查询请求。</li>\n<li><em>顶级域 DNS 服务器</em><br>除了前面提到的 <code>com</code> 是顶级域名，常见的顶级域名还有 <code>cn</code>、<code>org</code>、<code>edu</code> 等。<code>顶级域DNS服务器</code>，也就是 <code>TLD</code>，提供了它的下一级，也就是<code>权威DNS服务器</code>的 <code>IP</code> 地址。</li>\n<li><em>权威 DNS 服务器</em> &gt; <code>权威DNS服务器</code>可以返回 <code>主机 - IP</code> 的最终映射。<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bb796a3045e409aabb0f89ad40d3fad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\"></li>\n</ul></blockquote>\n<h4 id=\"TCP-建联-三次握手\"><a href=\"#TCP-建联-三次握手\" class=\"headerlink\" title=\"TCP 建联 - 三次握手\"></a>TCP 建联 - 三次握手</h4><ol>\n<li>客户端发送一个 TCP 的 SYN&#x3D;1，Seq&#x3D;X 的包到服务器端口</li>\n<li>服务器发回 SYN&#x3D;1， ACK&#x3D;X+1， Seq&#x3D;Y 的响应包</li>\n<li>客户端发送 ACK&#x3D;Y+1， Seq&#x3D;Z</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><em>为什么会采用三次握手，若采用二次握手可以吗？ 四次呢？</em><br>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B，因而产生错误。失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。</p>\n<p><em>采用两次握手为什么不行？</em><br>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/d8bf92c7906718271fdb8b0d2d5fe5b4~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\"></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/26/1643a1dd6df4813b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\"></p></blockquote>\n<h4 id=\"服务端处理请求并响应\"><a href=\"#服务端处理请求并响应\" class=\"headerlink\" title=\"服务端处理请求并响应\"></a>服务端处理请求并响应</h4><ol>\n<li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序</li>\n<li>服务器检查 HTTP 请求头是否包含缓存验证信息，如果验证缓存新鲜，返回 304 等对应状态码</li>\n<li>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作</li>\n<li>服务器将响应报文通过 TCP 连接发送回浏览器</li>\n</ol>\n<h4 id=\"TCP-断联-四次挥手\"><a href=\"#TCP-断联-四次挥手\" class=\"headerlink\" title=\"TCP 断联 - 四次挥手\"></a>TCP 断联 - 四次挥手</h4><ol>\n<li>主动方发送 Fin&#x3D;1， Ack&#x3D;Z， Seq&#x3D; X 报文</li>\n<li>被动方发送 ACK&#x3D;X+1， Seq&#x3D;Z 报文</li>\n<li>被动方发送 Fin&#x3D;1， ACK&#x3D;X， Seq&#x3D;Y 报文</li>\n<li>主动方发送 ACK&#x3D;Y， Seq&#x3D;X 报文</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><em>挥手为什么需要四次？</em><br>因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，”你发的 FIN 报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。</p>\n<p><em>四次挥手释放连接时，等待 2MSL 的意义?</em></p>\n<blockquote>\n<p>MSL 是 Maximum Segment Lifetime 的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote>\n</blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/8/16da9fd28b49f652~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\"> &gt; <img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/26/1643a20296de1ff0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\"></p></blockquote>\n<h4 id=\"浏览器处理响应\"><a href=\"#浏览器处理响应\" class=\"headerlink\" title=\"浏览器处理响应\"></a>浏览器处理响应</h4><ol>\n<li>浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同</li>\n<li>如果资源可缓存，进行缓存</li>\n<li>对响应进行解码（例如 gzip 压缩）</li>\n<li>根据资源类型决定如何处理（假设资源为 HTML 文档）</li>\n</ol>\n<h4 id=\"浏览器渲染\"><a href=\"#浏览器渲染\" class=\"headerlink\" title=\"浏览器渲染\"></a>浏览器渲染</h4><h5 id=\"构建-DOM-树\"><a href=\"#构建-DOM-树\" class=\"headerlink\" title=\"构建 DOM 树\"></a>构建 DOM 树</h5><ul>\n<li>Tokenizing：根据 HTML 规范将字符流解析为标记</li>\n<li>Lexing：词法分析将标记转换为对象并定义属性和规则</li>\n<li>DOM construction：根据 HTML 标记关系将对象组成 DOM 树</li>\n</ul>\n<h5 id=\"构建-CSSOM-树\"><a href=\"#构建-CSSOM-树\" class=\"headerlink\" title=\"构建 CSSOM 树\"></a>构建 CSSOM 树</h5><ul>\n<li>Tokenizing：字符流转换为标记流</li>\n<li>Node：根据标记创建节点</li>\n<li>CSSOM：节点创建 CSSOM 树</li>\n</ul>\n<h5 id=\"根据-DOM-树和-CSSOM-树构建渲染树\"><a href=\"#根据-DOM-树和-CSSOM-树构建渲染树\" class=\"headerlink\" title=\"根据 DOM 树和 CSSOM 树构建渲染树\"></a><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction\">根据 DOM 树和 CSSOM 树构建渲染树</a></h5><ul>\n<li>从 DOM 树的根节点遍历所有可见节点，不可见节点包括：<ul>\n<li>1）script,meta 这样本身不可见的标签。</li>\n<li>2)被 css 隐藏的节点，如 display: none</li>\n</ul>\n</li>\n<li>对每一个可见节点，找到恰当的 CSSOM 规则并应用</li>\n<li>发布可视节点的内容和计算样式</li>\n</ul>\n<h5 id=\"js-解析\"><a href=\"#js-解析\" class=\"headerlink\" title=\"js 解析\"></a>js 解析</h5><ul>\n<li>浏览器创建 <code>Document</code> 对象并解析 <code>HTML</code>，将解析到的元素和文本节点添加到文档中，此时 <code>document.readystate</code> 为 <code>loading</code></li>\n<li><code>HTML</code> 解析器遇到没有 <code>async</code> 和 <code>defer</code> 的 <code>script</code> 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 <code>document.write()</code> 把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 <code>script</code> 和他们之前的文档内容</li>\n<li>当解析器遇到设置了 <code>async</code> 属性的 <code>script</code> 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 <code>document.write()</code>，它们可以访问自己 <code>script</code> 和之前的文档元素</li>\n<li>当文档完成解析，<code>document.readState</code> 变成 <code>interactive</code></li>\n<li>所有 <code>defer</code> 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 <code>document.write()</code></li>\n<li>浏览器在 <code>Document</code> 对象上触发 <code>DOMContentLoaded</code> 事件</li>\n<li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，<code>document.readState</code> 变为 <code>complete</code>,<code>window</code> 触发 <code>load</code> 事件</li>\n</ul>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://juejin.cn/post/6990344840181940261\">字节面试被虐后，是时候搞懂 DNS 了</a><br><a href=\"https://github.com/jinxiaochuan/FE-interview#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BB%A5http%E4%B8%BA%E4%BE%8B\">从浏览器地址栏输入 url 到显示页面的步骤以 http 为例</a><br><a href=\"https://juejin.cn/post/6905931622374342670\">从输入 URL 到浏览器显示页面过程中都发生了什么？</a><br><a href=\"https://juejin.cn/post/6844903625513238541\">跟着动画来学习 TCP 三次握手和四次挥手</a><br><a href=\"https://juejin.cn/post/6844903958624878606\">面试官，不要再问我三次握手和四次挥手</a></p>\n","feature":true,"text":"资源是否命中强缓存 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证 检验新鲜通常有两个 HTTP 头进行控制 Expires 和 Cache-Control： HTTP1.0 提供 Expires，值为一个绝对时间表示缓存...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Interview","slug":"Interview","count":1,"path":"api/tags/Interview.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E6%98%AF%E5%90%A6%E5%91%BD%E4%B8%AD%E5%BC%BA%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">资源是否命中强缓存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#DNS-%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">DNS 解析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TCP-%E5%BB%BA%E8%81%94-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">TCP 建联 - 三次握手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">服务端处理请求并响应</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TCP-%E6%96%AD%E8%81%94-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">TCP 断联 - 四次挥手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">浏览器处理响应</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">浏览器渲染</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA-DOM-%E6%A0%91\"><span class=\"toc-text\">构建 DOM 树</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA-CSSOM-%E6%A0%91\"><span class=\"toc-text\">构建 CSSOM 树</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%8D%AE-DOM-%E6%A0%91%E5%92%8C-CSSOM-%E6%A0%91%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93%E6%A0%91\"><span class=\"toc-text\">根据 DOM 树和 CSSOM 树构建渲染树</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#js-%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">js 解析</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React Scheduler 实现原理","uid":"b0b8678218311a141892451e84682c39","slug":"react-scheduler","date":"2022-03-21T23:17:17.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/react-scheduler.json","keywords":null,"cover":[],"text":"Scheduler 时间分片如果「组件 Render 过程耗时」或「参与调和阶段的虚拟 DOM 节点很多」时，那么一次性完成所有组件的调和阶段就会花费较长时间。为了避免长时间执行调和阶段而引起页面卡顿，React 团队提出了 Fiber 架构和 Scheduler 任务调度。Fi...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"React","slug":"React","count":2,"path":"api/tags/React.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"NodeJS Stream","uid":"495c7f3561d14b86e5bb70506dad2bf9","slug":"nodejs-stream","date":"2022-03-19T10:44:57.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/nodejs-stream.json","keywords":null,"cover":[],"text":" Streams are Node’s best and most misunderstood idea. – Dominic Tarr Stream 是什么？ Streams are collections of data – just like arrays or strin...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","count":1,"path":"api/tags/NodeJS.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}