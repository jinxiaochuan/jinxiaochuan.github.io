{"total":15,"pageSize":12,"pageCount":2,"data":[{"title":"React Scheduler 实现原理","uid":"b0b8678218311a141892451e84682c39","slug":"react-scheduler","date":"2022-03-21T23:17:17.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/react-scheduler.json","cover":[],"text":"Scheduler 时间分片如果「组件 Render 过程耗时」或「参与调和阶段的虚拟 DOM 节点很多」时，那么一次性完成所有组件的调和阶段就会花费较长时间。为了避免长时间执行调和阶段而引起页面卡顿，React 团队提出了 Fiber 架构和 Scheduler 任务调度。Fi...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"React","slug":"React","count":2,"path":"api/tags/React.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"从浏览器地址栏输入url之后经历了什么？","uid":"dd5d3edb93e33be831adceee904530d0","slug":"visit-website","date":"2022-03-20T16:29:49.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/visit-website.json","cover":[],"text":"资源是否命中强缓存 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证 检验新鲜通常有两个 HTTP 头进行控制 Expires 和 Cache-Control： HTTP1.0 提供 Expires，值为一个绝对时间表示缓存...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Interview","slug":"Interview","count":1,"path":"api/tags/Interview.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"NodeJS Stream","uid":"495c7f3561d14b86e5bb70506dad2bf9","slug":"nodejs-stream","date":"2022-03-19T10:44:57.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/nodejs-stream.json","cover":[],"text":" Streams are Node’s best and most misunderstood idea. – Dominic Tarr Stream 是什么？ Streams are collections of data – just like arrays or strin...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","count":1,"path":"api/tags/NodeJS.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"webpack 打包优化","uid":"e76dee0a8c7a5ee4319d8141408a59cb","slug":"webpack-bundle-optimization","date":"2022-02-23T10:57:14.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/webpack-bundle-optimization.json","cover":null,"text":"webpack 打包优化我们知道 webpack 打包优化很重要，不论是优化开发体验还是优化打包速度、体积都是很有益处的 缩小文件搜索范围优化 loader 配置include/exclude 将 node_modules 中的文件进行包括&#x2F;排除 &#123; rule...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"webpack","slug":"webpack","count":1,"path":"api/tags/webpack.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"webpack 之 LoaderRunner 源码解读","uid":"82dcbf1a43d49c4fc7ea77c32662c2c0","slug":"webpack-loader-runner","date":"2022-02-22T17:27:27.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/webpack-loader-runner.json","cover":null,"text":"回顾 webpack 构建编译我们知道，webpack 整个的编译过程 compiler.run -&gt; [beforeRun hook -&gt; run hook] -&gt; compiler.compile -&gt; [beforeCompile hook -&gt...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"Webpack","slug":"Webpack","count":4,"path":"api/tags/Webpack.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Webpack 构建编译阶段","uid":"670e37e7b17df0fce5e221bac0d0bce1","slug":"webpack-stage-compiler","date":"2022-02-21T13:12:08.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/webpack-stage-compiler.json","cover":[],"text":"Webpack 核心之构建编译调用 compiler.run 方法来启动构建 run(callback) &#123; // 编译结束回调函数 const onCompiled = (err, compilation) => &#123; this.hooks.done.call...","link":"","photos":[],"count_time":{"symbolsCount":"9.6k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"Webpack","slug":"Webpack","count":4,"path":"api/tags/Webpack.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Webpack 初始化阶段","uid":"2f91216609991253bb8453ebedd72331","slug":"webpack-stage-init","date":"2022-02-19T22:52:44.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/webpack-stage-init.json","cover":[],"text":"Webpack 核心之初始化 Webpack 核心功能官方解释At its core, webpack is a static module bundler for modern JavaScript applications.将各种类型的资源，包括图片、css、js 等，转译、...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"Webpack","slug":"Webpack","count":4,"path":"api/tags/Webpack.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"React 合成事件系统","uid":"e8dd10177843eb97f466f57c44ebeb35","slug":"react-event-system","date":"2022-02-16T22:12:01.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/react-event-system.json","cover":[],"text":" JSX 事件绑定 -&gt; Fiberclass Index extends React.Component&#123; handerClick= (value) => console.log(value) render()&#123; return &lt;div> &lt...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"React","slug":"React","count":2,"path":"api/tags/React.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Source Map","uid":"f8393fb18aa0424e4c73686abd0807ce","slug":"sourcemap","date":"2022-02-16T18:13:27.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/sourcemap.json","cover":[],"text":"为什么需要 Source map？这个要从源码转换讲起，JavaScript 脚本正变得越来越复杂。大部分源码（尤其是各种函数库和框架）都要经过转换，才能投入生产环境。 常见的源码转换，主要是以下三种情况： （1）压缩，减小体积。比如 jQuery 1.9 的源码，压缩前是 25...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Webpack","slug":"Webpack","count":4,"path":"api/tags/Webpack.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Chrome 80+","uid":"1be78549da2d3dbc703ef7208cb57948","slug":"chrome80","date":"2022-02-13T14:20:14.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/chrome80.json","cover":[],"text":"Chrome 80 策略更新Chrome 80 稳定版（版本号 v80.0.3987.87）已正式面向 Windows、macOS、Linux、Android 和 iOS 全平台推送 混合内容强制 HTTPS混合内容是指 https 页面下有非 https 资源时，浏览器的加载策...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"CORS vs HSTS","uid":"78e195a173181f2e8327460e98bdacbc","slug":"cors","date":"2022-02-12T16:54:51.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/cors.json","cover":[],"text":"浏览器同源策略所谓同源就是浏览器的一个安全机制,不同源的客户端脚本没有在明确授权的情况下,不能读写对方资源。由于存在同源策略的限制,而又有需要跨域的业务,所以就有了 CORS 的出现。 当资源位于不同协议、子域或端口的站点时，这个请求就是跨域的 CORS 与 HSTSHSTS 全...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"HTTP","slug":"HTTP","count":2,"path":"api/tags/HTTP.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"浏览器缓存及内容协商","uid":"0f1e554315f0274ca298957330a8910f","slug":"broswer-cache","date":"2022-02-12T13:40:50.000Z","updated":"2022-03-21T17:03:46.347Z","comments":true,"path":"api/articles/broswer-cache.json","cover":[],"text":"浏览器的缓存机制浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的。 浏览器缓存过程： 强缓存、协商缓存。浏览器缓存位置一般分为四类： Service Worker、Memory Cache、Disk Cache、Push Cache...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"HTTP","slug":"HTTP","count":2,"path":"api/tags/HTTP.json"}],"author":{"name":"Matrix","slug":"blog-author","avatar":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/2/16c515569d19fc87~tplv-t2oaga2asx-no-mark:500:500:500:500.awebp","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}